# 
# Makefile for 'pcal' under MS-DOS
#
# v4.10.0: Bill Marr
#    
#    Fix a problem whereby the specification of the memory model to be used
#    was missing from the link stage.  Explicitly specify the memory model as
#    a variable.  Document the available memory models and their use.
#    
#    Enable a run-time check for stack overflow conditions by compiling with 
#    the '-N' option.
#    
#    Accommodate the fact that the use of 'pcalinit.{c,ps,h}' is no longer
#    needed.  PostScript output is now directly generated by C code, without
#    the use of a PostScript template which is converted to a C header file.
#    
#    Eliminate other now-unused files ('pcalglob.h', 'pcalpapr.{c,h}') and add
#    new files ('encvec.c', 'pcallang.c').
#    
#    Specify proper header file dependencies.  Several of them were incorrect.
#    
#    Rename 'EPS' definition to 'EPS_DSC' (in order to more clearly show its
#    purpose and to avoid confusion with the embedded EPS image capability for
#    monthly calendars).
#    
#    Provide several enhancements to the comments.
#    
# v4.9.0: Bill Marr
# 
#    Use 'src/' now that source files are in their own subdirectory.
# 
#    Add '-DEPS' switch to get EPS-compliant PostScript output.
# 
# v4.8.0: Bill Marr
# 
#    Change compiler command line to work under Borland C++ v5.0
# 
# v4.5: "make clean" leaves pcal intact but removes other by-products;
#       "make clobber" blows everything away;
#       "make fresh" rebuilds pcal from scratch
#
# Uses TurboC or Borland C++ command line compiler:
#    
#    make -f Makefile.DOS
# 
# Define various directories for the following items:
# 
#    - source code
#    - object code
#    - installed 'pcal' executable
# 
# This 'make' file mimics the Unix 'Makefile' file, by defining separate
# directories for the source, the objects, and the executable.  However,
# unlike the Unix compilers, the Borland C (DOS) compiler had trouble with
# creating the objects and executable code in subdirectories, so for now,
# we're just using the same actual destination directory ('.') for both of
# them.
# 
SRCDIR	= src
OBJDIR	= .
EXECDIR	= .

# 
# Use the Borland C++ compiler (v5.0)...
# 
CC = bcc

# 
# Select the appropriate memory model:
# 
#    t = tiny     (code+data < 64K)
#    s = small    (code < 64K, data < 64K)
#    c = compact  (code < 64K, data < 16M)
#    m = medium   (code < 16M, data < 64K)
#    l = large    (code < 16M, data < 16M)
#    h = huge     (same as 'large', but allows > 64K total static data)
# 
MODEL = h

# 
# This flag controls the generation of EPS-like PostScript Document
# Structuring Conventions (DSC) so that the output contains enhanced comments
# ('%%Page:', etc.) that are necessary for programs like 'psnup' to do useful
# things with the generated calendars.  These comments also allow PostScript
# previewer applications to page up to the previous page.
# 
D_EPS_DSC = -DEPS_DSC

# 
# Enable certain compile flags:
#    
#    -DBUILD_ENV_MSDOS   declare that we're building for MS-DOS
# 
# Borland compiler flags:
#    
#    -m($MODEL)   use specified memory model
#    -N           check for 'stack overflow' condition
#    -v-          disable debugging information
#    -w-ccc       disable warning 'Condition is always true/false'
#    -w-pia       disable warning 'Possibly incorrect assignment'
#    -w-rch       disable warning 'Unreachable code in function xxx'
#    -w-rvl       disable warning 'Function should return a value in function xxx'
#    -w-par       disable warning 'Parameter xxx is never used in function xxx'
#    -w-aus       disable warning 'xxx is assigned a value that is never used in function xxx'
#    
CFLAGS	= -DBUILD_ENV_MSDOS $(D_EPS_DSC) -I$(SRCDIR) \
		-m$(MODEL) -N -v- -w-ccc -w-pia -w-rch -w-rvl -w-par -w-aus

OBJECTS = $(OBJDIR)\pcal.obj \
		$(OBJDIR)\encvec.obj $(OBJDIR)\exprpars.obj \
		$(OBJDIR)\moonphas.obj $(OBJDIR)\pcalutil.obj \
		$(OBJDIR)\pcallang.obj \
		$(OBJDIR)\readfile.obj $(OBJDIR)\writefil.obj

$(EXECDIR)\pcal.exe:	$(OBJECTS)
	$(CC) -m$(MODEL) $(LDFLAGS) $(OBJECTS)
	@ echo Build of 'pcal' for MS-DOS completed.

$(OBJDIR)\encvec.obj:	$(SRCDIR)/encvec.c
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)/encvec.c

$(OBJDIR)\exprpars.obj:	$(SRCDIR)\exprpars.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\exprpars.c

$(OBJDIR)\moonphas.obj:	$(SRCDIR)\moonphas.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\pcallang.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\moonphas.c

$(OBJDIR)\pcal.obj:	$(SRCDIR)\pcal.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\pcallang.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\pcal.c

$(OBJDIR)\pcallang.obj:	$(SRCDIR)\pcallang.c $(SRCDIR)\pcallang.h \
			$(SRCDIR)\pcaldefs.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\pcallang.c

$(OBJDIR)\pcalutil.obj:	$(SRCDIR)\pcalutil.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\pcallang.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\pcalutil.c

$(OBJDIR)\readfile.obj:	$(SRCDIR)\readfile.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\pcallang.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -c $(SRCDIR)\readfile.c

$(OBJDIR)\writefil.obj:	$(SRCDIR)\writefil.c $(SRCDIR)\pcaldefs.h \
			$(SRCDIR)\pcallang.h \
			$(SRCDIR)\protos.h
	$(CC) $(CFLAGS) $(COPTS) -I$(OBJDIR) -c $(SRCDIR)\writefil.c

# 
# This target will delete everything except the 'pcal' executable.
# 
clean:
	del $(OBJDIR)\*.obj

# 
# This target will delete everything, including the 'pcal' executable.
# 
clobber: clean
	del $(EXECDIR)\pcal.exe

# 
# This target will delete everything and rebuild 'pcal' from scratch.
# 
fresh:	clobber pcal.exe
